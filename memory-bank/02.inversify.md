### Introduction

Inversify is a "A powerful and lightweight inversion of control container for JavaScript & Node.js apps powered by
TypeScript"

#### Inversify Basics

https://inversify.io/introduction/getting-started

#### saga-soa usage

The saga-soa project is the root project of a turborepo managed monorepo. There will be many submodules written in typescipt that implement both library and application functionality. I want to ensure inversfiy.io is used across these submodules to manage the instantiation of exports from each submodule in the importing module as well as internally within the submodule.

#### Requirements

1. **Interface-Based Design**
   - All concrete implementations must be abstracted behind interfaces
   - Services should be defined using TypeScript interfaces
   - Dependencies should be injected through constructor parameters

2. **Metadata-Based Binding**
   - Utilize TypeScript's emitted decorator metadata to automatically bind implementations to interfaces
   - Avoid manual creation of service identifiers where possible
   - Use `@injectable()` decorator on concrete implementations
   - Use `@inject()` decorator for constructor parameter injection

3. **Container Configuration**
   - Each submodule should export its own container configuration
   - Container configurations should be composable across the monorepo
   - Use `container.bind<Interface>().to(Implementation)` pattern
   - Leverage TypeScript's type system to ensure type safety

4. **Example Structure**
   ```typescript
   // Interface definition
   interface IUserService {
     getUser(id: string): Promise<User>;
   }

   // Concrete implementation
   @injectable()
   class UserService implements IUserService {
     constructor(
       @inject('IUserRepository') private userRepository: IUserRepository
     ) {}

     async getUser(id: string): Promise<User> {
       return this.userRepository.findById(id);
     }
   }

   // Container configuration
   const container = new Container();
   container.bind<IUserService>('IUserService').to(UserService);
   ```

5. **Best Practices**
   - Keep interfaces in separate files from implementations
   - Use meaningful interface names prefixed with 'I'
   - Document interfaces with JSDoc comments
   - Use dependency injection for all external dependencies
   - Avoid circular dependencies between modules
