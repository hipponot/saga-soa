import { z } from 'zod';
import { TypeGenerationError } from './types.js';

export interface TypeGeneratorOptions {
  name?: string;
  typePrefix?: string;
  includeUtils?: boolean;
}

export class TypeGenerator {
  generateType(schema: z.ZodSchema, typeName: string, options: TypeGeneratorOptions = {}): string {
    try {
      const typeDefinition = this.generateTypeDefinition(schema);

      return this.formatTypeDefinition(typeDefinition, typeName);
    } catch (error) {
      throw new TypeGenerationError(
        `Failed to generate type for ${typeName}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private generateTypeDefinition(schema: z.ZodSchema): string {
    // Handle different Zod schema types
    if (schema instanceof z.ZodObject) {
      return this.generateObjectType(schema);
    } else if (schema instanceof z.ZodArray) {
      return this.generateArrayType(schema);
    } else if (schema instanceof z.ZodUnion) {
      return this.generateUnionType(schema);
    } else if (schema instanceof z.ZodOptional) {
      return this.generateOptionalType(schema);
    } else if (schema instanceof z.ZodNullable) {
      return this.generateNullableType(schema);
    } else if (schema instanceof z.ZodEnum) {
      return this.generateEnumType(schema);
    } else if (schema instanceof z.ZodDefault) {
      return this.generateDefaultType(schema);
    } else if (schema instanceof z.ZodLiteral) {
      return this.generateLiteralType(schema);
    } else if (schema instanceof z.ZodString) {
      return 'string';
    } else if (schema instanceof z.ZodNumber) {
      return 'number';
    } else if (schema instanceof z.ZodBoolean) {
      return 'boolean';
    } else if (schema instanceof z.ZodDate) {
      return 'Date';
    } else if (schema instanceof z.ZodNull) {
      return 'null';
    } else if (schema instanceof z.ZodUndefined) {
      return 'undefined';
    } else if (schema instanceof z.ZodAny) {
      return 'any';
    } else if (schema instanceof z.ZodUnknown) {
      return 'unknown';
    } else {
      return 'any';
    }
  }

  private generateObjectType(schema: z.ZodObject<any>): string {
    const shape = schema.shape;
    const properties: string[] = [];

    for (const [key, value] of Object.entries(shape)) {
      const propertyType = this.generateTypeDefinition(value);
      properties.push(`  ${key}: ${propertyType};`);
    }

    return `{\n${properties.join('\n')}\n}`;
  }

  private generateArrayType(schema: z.ZodArray<any>): string {
    const elementType = this.generateTypeDefinition(schema.element);
    return `${elementType}[]`;
  }

  private generateUnionType(schema: z.ZodUnion<any>): string {
    const types = schema.options.map((option: z.ZodSchema) => this.generateTypeDefinition(option));
    return types.join(' | ');
  }

  private generateOptionalType(schema: z.ZodOptional<any>): string {
    const innerType = this.generateTypeDefinition(schema.unwrap());
    return `${innerType} | undefined`;
  }

  private generateNullableType(schema: z.ZodNullable<any>): string {
    const innerType = this.generateTypeDefinition(schema.unwrap());
    return `${innerType} | null`;
  }

  private generateEnumType(schema: z.ZodEnum<any>): string {
    const options = schema.options.map((option: string) => `'${option}'`);
    return options.join(' | ');
  }

  private generateDefaultType(schema: any): string {
    // For default values, we just return the inner type
    // The default value doesn't affect the TypeScript type
    const innerType = this.generateTypeDefinition(schema.unwrap() as any);
    return innerType;
  }

  private generateLiteralType(schema: z.ZodLiteral<any>): string {
    const value = schema.value;
    if (typeof value === 'string') {
      return `'${value}'`;
    }
    return String(value);
  }

  private formatTypeDefinition(typeDefinition: string, typeName: string): string {
    return `// Generated by zod2ts
// Do not edit manually

export type ${typeName} = ${typeDefinition};
`;
  }
}
