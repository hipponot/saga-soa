import { z } from 'zod';
import { TypeGenerationError } from './types.js';

export interface TypeGeneratorOptions {
  name?: string;
  typePrefix?: string;
  includeUtils?: boolean;
}

export class TypeGenerator {
  generateType(schema: z.ZodSchema, typeName: string, options: TypeGeneratorOptions = {}): string {
    try {
      const typeDefinition = this.generateTypeDefinition(schema);

      return this.formatTypeDefinition(typeDefinition, typeName);
    } catch (error) {
      throw new TypeGenerationError(
        `Failed to generate type for ${typeName}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  private generateTypeDefinition(schema: any): string {
    const typeName = (schema._def as any)?.typeName || (schema._def as any)?.type;
    
    // Handle different Zod schema types
    if (typeName === 'ZodObject' || typeName === 'object') {
      return this.generateObjectType(schema);
    } else if (typeName === 'ZodArray' || typeName === 'array') {
      return this.generateArrayType(schema);
    } else if (typeName === 'ZodUnion' || typeName === 'union') {
      return this.generateUnionType(schema);
    } else if (typeName === 'ZodOptional' || typeName === 'optional') {
      return this.generateOptionalType(schema);
    } else if (typeName === 'ZodNullable' || typeName === 'nullable') {
      return this.generateNullableType(schema);
    } else if (typeName === 'ZodEnum' || typeName === 'enum') {
      return this.generateEnumType(schema);
    } else if (typeName === 'ZodDefault' || typeName === 'default') {
      return this.generateDefaultType(schema);
    } else if (typeName === 'ZodLiteral' || typeName === 'literal') {
      return this.generateLiteralType(schema);
    } else if (typeName === 'ZodString' || typeName === 'string') {
      return 'string';
    } else if (typeName === 'ZodNumber' || typeName === 'number') {
      return 'number';
    } else if (typeName === 'ZodBoolean' || typeName === 'boolean') {
      return 'boolean';
    } else if (typeName === 'ZodDate' || typeName === 'date') {
      return 'Date';
    } else if (typeName === 'ZodNull' || typeName === 'null') {
      return 'null';
    } else if (typeName === 'ZodUndefined' || typeName === 'undefined') {
      return 'undefined';
    } else if (typeName === 'ZodAny' || typeName === 'any') {
      return 'any';
    } else if (typeName === 'ZodUnknown' || typeName === 'unknown') {
      return 'unknown';
    } else {
      return 'any';
    }
  }

  private generateObjectType(schema: any): string {
    const shape = (schema as z.ZodObject<any>).shape;
    const properties: string[] = [];

    for (const [key, value] of Object.entries(shape)) {
      const propertyType = this.generateTypeDefinition(value);
      properties.push(`  ${key}: ${propertyType};`);
    }

    return `{\n${properties.join('\n')}\n}`;
  }

  private generateArrayType(schema: any): string {
    const elementType = this.generateTypeDefinition((schema as z.ZodArray<any>).element);
    return `${elementType}[]`;
  }

  private generateUnionType(schema: any): string {
    const types = (schema as z.ZodUnion<any>).options.map((option: any) => this.generateTypeDefinition(option));
    return types.join(' | ');
  }

  private generateOptionalType(schema: any): string {
    const innerType = this.generateTypeDefinition((schema as z.ZodOptional<any>).unwrap());
    return `${innerType} | undefined`;
  }

  private generateNullableType(schema: any): string {
    const innerType = this.generateTypeDefinition((schema as z.ZodNullable<any>).unwrap());
    return `${innerType} | null`;
  }

  private generateEnumType(schema: any): string {
    const options = (schema as z.ZodEnum<any>).options.map((option: string) => `'${option}'`);
    return options.join(' | ');
  }

  private generateDefaultType(schema: any): string {
    // For default values, we just return the inner type
    // The default value doesn't affect the TypeScript type
    if (typeof schema.unwrap === 'function') {
      const innerType = this.generateTypeDefinition(schema.unwrap());
      return innerType;
    } else {
      // If unwrap doesn't exist, try to get the inner type from _def
      const innerDef = (schema._def as any)?.innerType;
      if (innerDef) {
        return this.generateTypeDefinition(innerDef);
      } else {
        return 'any';
      }
    }
  }

  private generateLiteralType(schema: any): string {
    const value = (schema as z.ZodLiteral<any>).value;
    if (typeof value === 'string') {
      return `'${value}'`;
    }
    return String(value);
  }

  private formatTypeDefinition(typeDefinition: string, typeName: string): string {
    return `// Generated by zod2ts
// Do not edit manually

export type ${typeName} = ${typeDefinition};
`;
  }
}
